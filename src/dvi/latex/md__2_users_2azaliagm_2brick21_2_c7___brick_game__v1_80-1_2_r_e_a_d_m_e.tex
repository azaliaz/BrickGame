\chapter{Brick\+Game Tetris}
\hypertarget{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e}{}\label{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e}\index{BrickGame Tetris@{BrickGame Tetris}}
\label{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md0}%
\Hypertarget{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md0}%
Summary\+: In this project, you need to implement the Tetris game in the C programming language using a structural approach.

ðŸ’¡ \href{https://new.oprosso.net/p/4cb31ec3f47a4596bc758ea1861fb624}{\texttt{ Tap here}} {\bfseries{to leave your feedback on the project}}. It\textquotesingle{}s anonymous and will help our team make your educational experience better. We recommend completing the survey immediately after the project.\hypertarget{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md1}{}\doxysection{\texorpdfstring{Contents}{Contents}}\label{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md1}

\begin{DoxyItemize}
\item Brick\+Game\+Tetris
\begin{DoxyItemize}
\item Contents
\item Introduction
\end{DoxyItemize}
\item Chapter I
\begin{DoxyItemize}
\item General Information
\begin{DoxyItemize}
\item Brick\+Game
\item History
\item Finite-\/state machines
\item Frogger
\item Tetris
\end{DoxyItemize}
\end{DoxyItemize}
\item Chapter II
\begin{DoxyItemize}
\item Project Requirments
\begin{DoxyItemize}
\item Part 1. Main task
\item Part 2. Bonus. Scoring and game record
\item Part 3. Bonus. Level mechanics
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md2}{}\doxysubsection{\texorpdfstring{Introduction}{Introduction}}\label{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md2}
The project must consist of two parts to implement the Tetris game\+: a library that implements the logic of the game, which can be connected to different GUIs in the future, and a terminal interface. The logic of the library must be implemented using finite-\/state machines, one of the possible descriptions of which is given below.\hypertarget{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md3}{}\doxysubsection{\texorpdfstring{Chapter I }{Chapter I }}\label{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md3}
\hypertarget{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md4}{}\doxysection{\texorpdfstring{General information}{General information}}\label{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md4}
\hypertarget{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md5}{}\doxysubsubsection{\texorpdfstring{Brick\+Game}{Brick\+Game}}\label{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md5}
Brick\+Game is a popular handheld console from the 90s with several \sout{thousands} of built-\/in games developed in China. It was originally a copy of Tetris developed in the USSR and released by Nintendo as part of the Game\+Boy platform, but also included many other games that were added over time. The console had a small screen with a 10x20 playing field that was a matrix of "{}pixels"{}. To the right of the field was a scoreboard with a digital display of the current game status, records, and other additional information. The most popular games on Brick\+Game were Tetris, Tanks, Racing, Frogger and Snake.

\hypertarget{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md6}{}\doxysubsubsection{\texorpdfstring{History}{History}}\label{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md6}
Tetris was created on an Electronica-\/60 computer by Alexey Pajitnov on June 6, 1984. The game was a puzzle based on the use of "{}tetraminoes"{} â€” shaped pieces consisting of four squares. The first commercial version of the game was released in the United States in 1987. In the following years, Tetris was ported to many different devices, including mobile phones, pocket calculators and PDAs.

The most popular version of Tetris is the one for the Game Boy and NES consoles. But there are several other versions of the game. For example, there\textquotesingle{}s a version with three-\/dimensional pieces, or a duel version where two players get the same pieces and try to beat each other in scoring.\hypertarget{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md7}{}\doxysubsubsection{\texorpdfstring{Finite-\/state machines}{Finite-\/state machines}}\label{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md7}
A finite-\/state machine (FSM) in algorithm theory is a mathematical abstraction, a model of a discrete device that has an input, an output, and is in one of a set of possible states at any given time.

During operation, the input of the FSM receives input actions sequentially, and the output of the FSM generates output signals. Transition from one internal state to another can occur not only by external action, but also spontaneously.

FSM can be used to describe algorithms for solving specific problems, as well as to model almost any process. Some examples\+:


\begin{DoxyItemize}
\item Artificial intelligence game logic;
\item Syntactic and lexical analysis;
\item Complex application network protocols;
\item Streaming data.
\end{DoxyItemize}

Below are examples of using FSM to formalize the game logic of a few games from Brick\+Game.\hypertarget{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md8}{}\doxysubsubsection{\texorpdfstring{Frogger}{Frogger}}\label{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md8}


Frogger is one of the later games released for the Brickgame consoles. The game consists of a playing field on which logs move, and the player has to guide the frog from one side to the other by jumping over them. If the player hits the water or the frog moves outside the playing field, the frog dies. The game ends when the player gets the frog to the other side, or when the last frog dies.

To formalize the logic of this game, the following variant of a finite state machine can be introduced\+:



This FSM has the following states\+:


\begin{DoxyItemize}
\item Start is the state where the game is waiting for the player to press the ready button.
\item Spawn is the state where the next frog is created.
\item Moving is the main game state with user input processing â€” moving the frog left/right along the path or jumping forward/backward.
\item Shift is the state that occurs after the timer runs out, where all objects on the paths are shifted to the right along with the frog.
\item Collision is a state that occurs when the frog hits the water after jumping, or when the frog is outside the playing field after moving logs.
\item Reached the other side is the state that occurs when a frog reaches the other side.
\item Game over is the state that occurs after reaching the other side of the river, or when the last frog dies.
\end{DoxyItemize}

An example of implementing a frogger using FSM can be found in the {\ttfamily code-\/samples} folder.\hypertarget{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md9}{}\doxysubsubsection{\texorpdfstring{Tetris}{Tetris}}\label{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md9}


Tetris is probably one of the most popular games for the Brickgame console. It\textquotesingle{}s not uncommon for the console itself to be called Tetris. The goal of the game is to score points by building lines of blocks generated by the game. The next block generated by the game starts moving down the board until it reaches the bottom border or collides with another block. The user can rotate the blocks and move them horizontally, trying to make rows. Once a row is filled, it is destroyed, the player scores points, and the blocks above the filled row fall down. The game ends when the next piece stops in the top row.

To formalize the logic of this game, the following variant of a finite state machine can be introduced\+:



This FSM has the following states\+:


\begin{DoxyItemize}
\item Start is the state in which the game waits for the player to press the ready button.
\item Spawn is the state the game enters when you create another block and select the next block to spawn.
\item Moving is the main game state with user input processing â€” rotating blocks/moving blocks horizontally.
\item Move is the state the game enters after the timer runs out. It moves the current block down one level.
\item Attaching is the state the game enters after the current block "{}touches"{} the already fallen blocks or the ground. If full rows are created, it is destroyed and the remaining blocks are moved down. If a block is stopped in the top row, the game enters the "{}game over"{} state.
\item Game over is the end of the game.
\end{DoxyItemize}\hypertarget{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md10}{}\doxysubsection{\texorpdfstring{Chapter II }{Chapter II }}\label{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md10}
\hypertarget{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md11}{}\doxysubsection{\texorpdfstring{Project Requirements}{Project Requirements}}\label{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md11}
\hypertarget{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md12}{}\doxysubsubsection{\texorpdfstring{Part 1. Main task}{Part 1. Main task}}\label{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md12}
You need to implement the Brick\+Game v1.\+0 aka Tetris program\+:


\begin{DoxyItemize}
\item The program must be developed in C language of the C11 standard using the gcc compiler.
\item The program must consist of two parts\+: a library implementing the logic of the Tetris game, and a terminal interface using the {\ttfamily ncurses} library.
\item A finite state machine must be used to formalize the logic of the game.
\item The library must have a function that accepts user input and a function that outputs a matrix describing the current state of the playing field whenever it is changed.
\item The library code must be placed in the {\ttfamily src/brick\+\_\+game/tetris} folder.
\item The program interface code must be in the {\ttfamily src/gui/cli} folder.
\item The program must be built using a Makefile with the standard set of targets for GNU programs\+: all, install, uninstall, clean, dvi, dist, test, gcov\+\_\+report. The installation directory can be arbitrary.
\item The program must be developed according to the principles of structured programming.
\item Follow Google Style when writing code.
\item Prepare full coverage of the library with unit tests, using the {\ttfamily check} library (tests must run on Darwin/\+Ubuntu OS). The coverage of the library with game logic with tests must be at least 80 percent.
\item The following mechanics must be present in the game\+:
\begin{DoxyItemize}
\item Rotation of pieces;
\item Horizontal movement of pieces;
\item Acceleration of the piece\textquotesingle{}s fall (when the button is pressed, the piece moves all the way down);
\item Displaying the next piece;
\item Destruction of filled rows;
\item End of the game when the top of the board is reached;
\item All types of pieces shown in the picture below must be included in the game.
\end{DoxyItemize}
\item Add support for all buttons provided on the physical console for control\+:
\begin{DoxyItemize}
\item Start game,
\item Pause,
\item End game,
\item Left arrow â€” move the piece to the left,
\item Right arrow â€” move piece to the right,
\item Down arrow â€” piece falls,
\item Up arrow is not used in this game,
\item Action (piece rotation).
\end{DoxyItemize}
\item The playing area must be the same size as the console\textquotesingle{}s playing field â€” ten "{}pixels"{} wide and twenty "{}pixels"{} high.
\item When the figure reaches the lower boundary of the board or touches another figure, it must stop. After that, the next piece, shown in the preview, is generated.
\item The library interface must match the description in materials/library-\/specification.\+md.
\item The UI must support rendering of the playing field and additional information.
\item Prepare a diagram in any format describing the FSM used (its states and all possible transitions).
\end{DoxyItemize}

Pieces used\+:

\hypertarget{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md13}{}\doxysubsubsection{\texorpdfstring{Part 2. Bonus. Scoring and game record}{Part 2. Bonus. Scoring and game record}}\label{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md13}
Add the following mechanics to the game


\begin{DoxyItemize}
\item Scoring;
\item Store maximum score.
\end{DoxyItemize}

This information must be passed and displayed by the user interface in the sidebar. The maximum score must be stored in a file or an embedded DBMS and saved between program runs.

The maximum score must be changed during the game if the user exceeds the current maximum score.

Points are accumulated as follows\+:


\begin{DoxyItemize}
\item 1 row is 100 points;
\item 2 rows is 300 points;
\item 3 rows is 700 points;
\item 4 rows is 1500 points.
\end{DoxyItemize}\hypertarget{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md14}{}\doxysubsubsection{\texorpdfstring{Part 3. Bonus. Level mechanics}{Part 3. Bonus. Level mechanics}}\label{md__2_users_2azaliagm_2brick21_2_c7___brick_game__v1_80-1_2_r_e_a_d_m_e_autotoc_md14}
Add level mechanics to the game. Each time a player earns 600 points, the level increases by 1. Increasing the level increases the speed at which the pieces move. The maximum number of levels is 10. 